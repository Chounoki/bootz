// Copyright 2023 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package bootz;

import "google/protobuf/struct.proto";

import "github.com/openconfig/attestz/proto/tpm_enrollz.proto";
import "github.com/openconfig/gnsi/authz/authz.proto";
import "github.com/openconfig/gnsi/certz/certz.proto";
import "github.com/openconfig/gnsi/credentialz/credentialz.proto";
import "github.com/openconfig/gnsi/pathz/pathz.proto";

option go_package = "github.com/openconfig/bootz/proto/bootz";

// The Bootz service definition.
// Bootz service is hosted by the bootz-server, and the device is the
// client (as opposed to most g*i services, which are hosted by the device).
service Bootstrap {
  // This RPC returns the data required to put the device in a known state
  // (i.e. OS, bootloader password, etc) and applies an initial device
  // configuration.
  // The device must use its IDevID certificate in the gRPC TLS handshake.
  rpc GetBootstrapData(GetBootstrapDataRequest)
      returns (GetBootstrapDataResponse) {}

  // This RPC is used by the device to indicate successful application of
  // BootstrappingData. The Bootz system will proceed to the next step if
  // a SUCCESS is reported, otherwise it will retry or put the device in an
  // out-of-service state. The device should validate the server's identity
  // against the server_trust_cert it obtained in GetBootstrappingDataResponse.
  // The device must use its IDevID certificate in the gRPC TLS handshake.
  rpc ReportStatus(ReportStatusRequest) returns (EmptyResponse) {}

  // Deprecated. Use BootstrapStreamV1 RPC below instead.
  rpc BootstrapStream(stream BootstrapStreamRequest)
      returns (stream BootstrapStreamResponse) {}

  // Streaming Bootz v1.0 protocol.
  // This PRC provides the streaming implementation of the Bootz
  // service. This flow allows for both server and client validation via
  // IDevID, EK or PPK, which bypasses the need of the device presenting
  // the IDevID certificate during the initial gRPC TLS handshake.
  // The workflow should follow:
  //
  //   (Device to Bootz) BootstrapStreamRequestV1.bootstrap_request
  //   (Bootz to Device) BootstrapStreamResponseV1.challenge_request
  //   (Device to Bootz) BootstrapStreamRequestV1.challenge_response
  //   (Bootz to Device) BootstrapStreamResponseV1.bootstrap_response
  //   (Device to Bootz) BootstrapStreamRequestV1.report_status_request
  //   (Bootz to Device) BootstrapStreamResponseV1.report_status_response
  //
  // NOTE: The device can send multiple report_status_request messages to keep
  // updating the real time status until the bootstrap is finished or failed.
  rpc BootstrapStreamV1(stream BootstrapStreamRequestV1)
      returns (stream BootstrapStreamResponseV1) {}
}

// Identity describes how the device will prove its identity to the Bootstrap
// server during the BootstrapStream() RPC.
// For systems which support IDevID that will be the preferred method.
// If identity is set, one of the types must be set or an error is returned.
message Identity {
  oneof type {
    // idevid_cert will be validated via OVGS (Ownership Voucher gRPC Service)
    // and the vendor CA bundle.
    // Additionally it will be used to validate the nonce_signed.
    // The format is either a single base64 encoded x509 DER certificate (IDevID
    // cert itself), or a chain of PEM encoded certificates. Note that the first
    // PEM encoded certificate in the chain must be the leaf certificate (i.e.
    // the IDevID cert itself); while the rest PEM encoded certificates in
    // the chain (if any) must be the intermediate certificates.
    string idevid_cert = 1;
    // EK public key in ASN.1 DER endocding for TPM 2.0 without IDevID systems.
    // NOTE: The content in this field only serves as a reference for debugging.
    // The actual EK public key will be retrieved from OVGS database.
    bytes tpm20_ek_pub = 6;
    // PPK public key in ASN.1 DER endocding for TPM 2.0 without IDevID systems.
    // NOTE: The content in this field only serves as a reference for debugging.
    // The actual PPK public key will be retrieved from OVGS database.
    bytes tpm20_ppk_pub = 7;
    // EK public key in ASN.1 DER encoding for TPM 1.2 systems.
    // NOTE: The content in this field only serves as a reference for debugging.
    // The actual EK public key will be retrieved from OVGS database.
    bytes tpm12_ek_pub = 8;

    // TPM 1.2
    bool ek_pub = 2 [deprecated = true];
    // TPM 2.0 without IDevId. Device supports both EK and PPK.
    bool ek_ppk_pub = 5 [deprecated = true];
  }

  // Deprecated fields. Do not reuse.
  reserved 3, 4;
}

// Initial request from device to the bootz-server. Contains a detailed
// description of the chassis and its constituent control cards.
message GetBootstrapDataRequest {
  ChassisDescriptor chassis_descriptor = 1;
  // Describes the current state of the active control card making the
  // bootstrap request. For fixed form factor devices, the active control
  // card is the chassis itself.
  ControlCardState control_card_state = 2;
  // A nonce that the bootstrap server should use when signing the response.
  // Not setting this field indicates that the device is configured not to
  // check for ownership voucher (for testing only).
  // NOTE: For production releases, the device should always validate the
  // ownership voucher, the bootstrap data signature and the nonce inside
  // the BootstrapDataSigned message.
  string nonce = 1001;
  // Identity will contain information used to validate the identity
  // of the device.
  // For systems which support IDevID that will be the preferred method.
  // If identity is set, one of the types must be set or an error is
  // returned.
  Identity identity = 1003;
  // The SHA1 digest over the placeholder AIK public key, while the
  // placeholder AIK public key itself (which is a TPM_PUBKEY structure)
  // is generated by the device invoking TPM_MakeIdentity command.
  // NOTE: This field is only populated for TPM 1.2 systems.
  bytes aik_pub_digest = 1004;
}

// BootstrapStreamRequest is used to both send chassis information
// as well as build a trust relationship if the IDevID cert is not used
// during TLS setup.
message BootstrapStreamRequest {
  message Response {
    oneof type {
      // Nonce signed with IAK from the device for TPM 2.0 IDevID based systems.
      bytes nonce_signed = 1;
      // Nonce decrypted via EK for TPM 1.2 systems.
      string nonce = 2;
      // HMAC challenge response for TPM 2.0 no-IDevID systems.
      openconfig.attestz.HMACChallengeResponse hmac_challenge_response = 3;
    }
  }

  message EKIdentityRequest {
    // TPM 1.2 DER-encoded EK RSA public key.
    bytes ek_pub = 1;
    // 'prgbTCPAIdentityReq' argument of Tspi_TPM_CollateIdentityRequest
    // defined in TCG Software Stack (TSS) Specification Version 1.2 Level 1
    // section 4.3.4.6.3 whose definition is in TCPA version 1.1b Section
    // 4.30.2 - TCPA_IDENTITY_REQ
    bytes identity_request = 2;
  }

  oneof type {
    GetBootstrapDataRequest bootstrap_request = 1;
    Response response = 2;
    ReportStatusRequest report_status_request = 3;
    EKIdentityRequest ek_identity_request = 4;
  }

  // Deprecated fields. Do not reuse.
  reserved 5, 6;
}

// BootstrapStreamResponse will be returned based on the request from the
// client. The challenge will be based on the Identity message provided in
// the initial GetBootstrapDataRequest message.
message BootstrapStreamResponse {
  message Challenge {
    message TPM20HMACChallenge {
      // The public key to be used, which can be either EK or PPK.
      openconfig.attestz.Key key = 1;
      // The HMAC challenge to be imported by the TPM.
      openconfig.attestz.HMACChallenge hmac_challenge = 2;
    }

    oneof type {
      // The nonce to be signed by IAK for TPM 2.0 IDevID based systems.
      string nonce = 1;
      // Bootz server self-signed CA public cert for TPM 1.2 systems.
      bytes ca_pub = 3;
      // HMAC challenge for TPM 2.0 no-IDevID systems.
      TPM20HMACChallenge tpm20_hmac_challenge = 5;
    }

    // Deprecated fields. Do not reuse.
    reserved 2, 4;
  }

  message EKIdentityResponse {
    // TPM 1.2 challenge
    bytes asymmetric = 1;
    bytes symmetric = 2;
  }

  oneof type {
    Challenge challenge = 1;
    GetBootstrapDataResponse bootstrap_response = 2;
    EmptyResponse report_status_response = 3;
    EKIdentityResponse ek_identity_response = 4;
  }
}

// Structured message containing the chassis details, and listing its component
// control card modules.
message ChassisDescriptor {
  string manufacturer = 1;
  string part_number = 2;
  // This field must be populated for fixed form factor chassis.
  // The serial number can be empty for modular chassis.
  string serial_number = 3;
  // For modular chassis this field will be used to list the control cards
  // to be bootstrapped.
  repeated ControlCard control_cards = 4;
}

// Details of the control card, including serial number and the location
// of the card on the chassis.
message ControlCard {
  string part_number = 1;
  string serial_number = 2;
  string slot_id = 4;

  // Deprecated fields. Do not reuse.
  reserved 3;
}

// ControlCardState indicates if the bootstrap process has
// successfully completed.
//
// At the beginning of the bootstrap process (i.e. before a
// ReportStatus has completed with BOOTSTRAP_STATUS_SUCCESS),
// all control cards (1 or 2) are in NOT_INITIALIZED state.
// If bootstrap successfully completes for a control card, its
// ControlCardStatus changes to INITIALIZED.
//
// Once a control card is in INITIALIZED state, it may remain in that
// state indefinitely, even if removed and reinstalled in a chassis.
//
// When there are 2 control cards present and INITIALIZED then one is
// removed, the remaining control card remains in INITIALIZED state.
// If a new control card is inserted which has never completed the
// bootstrap process, it will start with NOT_INITIALIZED state.
message ControlCardState {
  enum ControlCardStatus {
    // The bootstrap process status is not reported.
    CONTROL_CARD_STATUS_UNSPECIFIED = 0;
    // The bootstrap process has not successfully completed.
    CONTROL_CARD_STATUS_NOT_INITIALIZED = 1;
    // The bootstrap process has successfully completed.
    CONTROL_CARD_STATUS_INITIALIZED = 2;
  }

  // serial_number must align with the serial number of the provided
  // control card in the chassis descriptor.
  string serial_number = 1;
  ControlCardStatus status = 2;
}

message BootstrapDataResponse {
  // The serial number of the control card to which this bootstrap data
  // should be applied.
  string serial_num = 1;
  // The device should download and install this image (or skip if the
  // device is already running it).
  SoftwareImage intended_image = 2;
  // The device should set this hash as its Bootloader password.
  string boot_password_hash = 3;
  // This certificate should be used to validate the server when reporting
  // progress. The format is a base64 encoding of an x509 DER certificate.
  string server_trust_cert = 4;
  // Boot configuration is specified as structured data.
  BootConfig boot_config = 5;
  Credentials credentials = 6;
  gnsi.pathz.v1.UploadRequest pathz = 7;
  gnsi.authz.v1.UploadRequest authz = 8;
  CertzProfiles certz_profiles = 10;

  // Deprecated fields. Do not reuse.
  reserved 9;
}

// CertzProfiles contains the Certz profiles and entities to create.
// The profiles cannot contain duplicate ID's and must never contain
// the ID `system_default_profile`.
message CertzProfiles {
  repeated CertzProfile profiles = 1;
}

// CertzProfile contains the profile ID and Certz entities for the profile.
message CertzProfile {
  string ssl_profile_id = 1;
  gnsi.certz.v1.UploadRequest certz = 2;
}

// Container message that is signed by server.
// the nonce is added to verify the contents from the client.
message BootstrapDataSigned {
  repeated BootstrapDataResponse responses = 1;
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  string nonce = 2;
}

message GetBootstrapDataResponse {
  // DEPRECATED: Use serialized_bootstrap_data instead.
  // Contains the signed bootstrap response. Deserialization of this
  // field is not stable so the response_signature should not be used
  // to verify this.
  // TODO(gmcfarlane): Remove this field once we verify that all devices are
  // using serialized_bootstrap_data.
  BootstrapDataSigned signed_response = 1 [deprecated = true];
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a CMS message (RFC 5652) signed by a trusted
  // vendor Certificate Authority.
  bytes ownership_voucher = 101;
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a CMS message (RFC 5652) which includes and is
  // signed by the OwnershipCertificate.
  bytes ownership_certificate = 102;
  // This is a signature of the serialized_bootstrap_data field,
  // using the ownership_certificate.
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a base64-encoding of a signature generated using PKCS1v15
  // with SHA256 as the hashing algorithm.
  string response_signature = 103;
  // This field contains a serialized (in wire format encoding) yet
  // unencrypted BootstrapDataSigned message. This field should be verified
  // against the response_signature before unmarshalling.
  bytes serialized_bootstrap_data = 104;
}

// Fields required by the device to be able to download and verify an image.
// The format of this message is identical to the `boot-image` data
// model outlined in the sZTP RFC:
// https://datatracker.ietf.org/doc/html/rfc8572#section-6.1
message SoftwareImage {
  // The name of the operating system software the device should be running.
  string name = 1;
  // The version of the operating system software the device should be running.
  string version = 2;
  // An HTTP location from where the OS file can be downloaded.
  string url = 3;
  // Hash of the OS image. The device must verify that the hash of the
  // downloaded OS image matches this. The format of this field is a
  // `hex-string`, identified in RFC6991 as "A hexadecimal string with
  // octets represented as hex digits separated by colons.
  // The canonical representation uses lowercase characters."
  // E.g.: "d9:a5:d1:0b:09:fa:4e:96:f2:40:bf:6a:82:f5"
  string os_image_hash = 4;
  // The identity of the hash algorithm used. These hash identities are
  // defined in sZTP RFC 8572. There is currently only one hash algorithm
  // defined in this spec:
  // `ietf-sztp-conveyed-info:sha-256` for the SHA 256 algorithm.
  string hash_algorithm = 5;
}

message Credentials {
  repeated gnsi.credentialz.v1.AuthorizedKeysRequest credentials = 1;
  repeated gnsi.credentialz.v1.AuthorizedUsersRequest users = 2;
  repeated gnsi.credentialz.v1.PasswordRequest passwords = 3;
}

message BootConfig {
  // Proprietary key-value pairs that are required as part of boot
  // configuration (e.g., feature flags, or vendor-specific hardware knobs).
  google.protobuf.Struct metadata = 1;

  // Fields to store the configuration that is expected of a device at boot
  // time. In all cases, the configuration used on the system is computed based
  // on the union of vendor_config + oc_config + dynamic_vendor_config +
  // dynamic_oc_config. The union should be performed according to the same
  // rules as `union_replace` in gNMI.
  //
  // Note, the dynamic_* fields MUST only be considered in the context of a
  // `BootstrapDataResponse` and are NOT valid when a `BootConfig` is updated
  // after device bootstrapping/initialisation -- for example, through
  // `gnoi.bootconfig.SetBootConfig`. In the case that these fields are
  // populated in the `SetBootConfig` RPC, an error with the code
  // `InvalidArgument` MUST be returned.
  //
  // vendor_config and oc_config specify boot configuration that is considered
  // immutable per the specification described in github.com/openconfig/bootz.
  //
  // Native format vendor configuration.
  bytes vendor_config = 2;
  // JSON rendered OpenConfig configuration.
  bytes oc_config = 3;

  // dynamic_vendor_config and dynamic_oc_config specify boot configuration
  // that is required at boot time, but can be overwritten by dynamic
  // configuration such as that applied by a gnmi.Set RPC call.
  //
  // As per the above comment dynamic_vendor_config and dynamic_oc_config
  // are ONLY valid in the context of `BootstrapDataResponse`.
  //
  // Native format vendor configuration.
  bytes dynamic_vendor_config = 5;
  // JSON rendered OpenConfig configuration.
  bytes dynamic_oc_config = 6;

  // Bootloader key-value pairs that are required as part of boot
  // configuration.
  google.protobuf.Struct bootloader_config = 4;
}

// The device reports the status of applying bootstrap data using this service.
// The status_message is a human-readable message indicating the nature of
// failure, if any.
message ReportStatusRequest {
  enum BootstrapStatus {
    BOOTSTRAP_STATUS_UNSPECIFIED = 0;
    BOOTSTRAP_STATUS_SUCCESS = 1;
    BOOTSTRAP_STATUS_FAILURE = 2;
    BOOTSTRAP_STATUS_INITIATED = 3;
  }
  BootstrapStatus status = 1;
  string status_message = 2;
  // Lists the current states of all control cards in the chassis.
  // For a fixed form factor chassis, this should contain a single
  // state matching the chassis serial number.
  repeated ControlCardState states = 3;
  // Identity will contain information used to validate the identity
  // of the device.
  // For systems which support IDevID that will be the preferred method.
  // If identity is set, one of the types must be set or an error is
  // returned.
  Identity identity = 4;
}

// Used in RPC methods that are not expected to return a response.
message EmptyResponse {
}

// BootMode specifies if the chassis should utilize Ownership Voucher data.
// Secure mode uses the Ownership Voucher validation.
enum BootMode {
  BOOT_MODE_UNSPECIFIED = 0;
  BOOT_MODE_INSECURE = 1;
  BOOT_MODE_SECURE = 2;
}

// The hybrid public key encryption cipher suite.
enum HPKECipherSuite {
  // Unspecified or invalid encryption. Do NOT use.
  HPKE_CIPHER_SUITE_UNSPECIFIED = 0;
  // No encryption (for testing only).
  // NOTE: Bootz server may reject this in production releases.
  HPKE_CIPHER_SUITE_NONE = 1;
  // A non-PQC cipher suite.
  // - Key Encapsulation Mechanism: DHKEM(X25519, HKDF-SHA256)
  // - Key Derivation Function: HKDF-SHA256
  // - AEAD: AES-256-GCM
  HPKE_CIPHER_SUITE_X25519_HKDF_SHA256_HKDF_SHA256_AES_256_GCM = 2;
}

// The transport key for encrypting bootstrap data.
message TransportKey {
  // The cipher suite in use.
  HPKECipherSuite cipher_suite = 1;
  // The output of SerializePublicKey() according to HPKE RFC9180.
  bytes public_key = 2;
  // The nonce copied from the challenge request, if applicable.
  // Otherwise, not populated.
  bytes nonce = 3;
}

message StreamBootstrapDataResponse {
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a CMS message (RFC 5652) signed by a trusted
  // vendor Certificate Authority.
  bytes ownership_voucher = 1;
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a CMS message (RFC 5652) which includes and is
  // signed by the OwnershipCertificate.
  bytes ownership_certificate = 2;
  // This is a signature of the encrypted_serialized_bootstrap_data field,
  // using the ownership_certificate.
  // This should not be set if the device does not check for ownership
  // voucher, which is indicated by the device not setting the nonce field
  // in the GetBootstrapDataRequest message.
  // The field is a base64-encoding of a signature generated using PKCS1v15
  // with SHA256 as the hashing algorithm.
  string response_signature = 3;
  // This field contains a serialized (in wire format encoding)
  // BootstrapDataSigned message, encrypted to the HPKE cipher suite.
  // The device should first verify this field against the response_signature,
  // then decrypt it using the HPKE cipher suite, before unmarshalling.
  bytes encrypted_serialized_bootstrap_data = 4;
}

// BootstrapStreamRequestV1 is sent from the device to Bootz server for
// conveying chassis information, responding to challenge request and
// reporting status.
message BootstrapStreamRequestV1 {
  message ChallengeResponse {
    message ChallengeResponseTPM20IDevID {
      // A serialized TransportKey message with nonce field copied from the
      // challenge request.
      bytes serialized_transport_key = 1;
      // The signature over serialized_transport_key, signed by the IDevID.
      bytes signature = 2;
    }
    message ChallengeResponseTPM20HMAC {
      // A serialized TransportKey message with nonce field not populated.
      bytes serialized_transport_key = 1;
      // The certify info generated by invoking TPM2_Certify command with the
      // imported HMAC key.
      // IMPORTANT: When invoking TPM2_Certify command, the qualifyingData
      // argument must be set to the SHA256 hash over serialized_transport_key.
      openconfig.attestz.HMACChallengeResponse hmac = 2;
    }
    message ChallengeResponseTPM12EK {
      // A serialized TransportKey message with nonce field not populated.
      bytes serialized_transport_key = 1;
      // The hash over serialized_transport_key, generated by HMAC-SHA256.
      bytes hash = 2;
    }

    oneof type {
      // IDevID challenge response for TPM 2.0 with IDevID systems.
      ChallengeResponseTPM20IDevID tpm20_idevid = 1;
      // HMAC challenge response for TPM 2.0 without IDevID systems.
      ChallengeResponseTPM20HMAC tpm20_hmac = 2;
      // EK challenge response for TPM 1.2 systems.
      ChallengeResponseTPM12EK tpm12_ek = 3;
    }
  }

  oneof type {
    GetBootstrapDataRequest bootstrap_request = 1;
    ChallengeResponse challenge_response = 2;
    ReportStatusRequest report_status_request = 3;
  }
}

// BootstrapStreamResponseV1 is sent from Bootz server to the device for
// creating the challenge request, conveying the bootstrap data and
// acknowledging the status report.
message BootstrapStreamResponseV1 {
  message ChallengeRequest {
    message ChallengeRequestTPM20IDevID {
      // The nonce that should be copied into the TransportKey message inside
      // the challenge response.
      bytes nonce = 1;
    }
    message ChallengeRequestTPM20HMAC {
      // The HMAC key encrypted to EK/PPK.
      // The device should invoke TPM2_Import command to import this HMAC key
      // into the TPM.
      // NOTE: Whether it is encrypted to EK or PPK is decided by the identity
      // (tpm20_ek_pub or tpm20_ppk_pub) presented by the device.
      openconfig.attestz.HMACChallenge hmac_encrypted = 2;
    }
    message ChallengeRequestTPM12EK {
      // The blob (a TPM_ASYM_CA_CONTENTS structure whose sessionKey field
      // contains an HMAC-SHA256 key) encrypted to the EK.
      // The device should invoke TPM_ActivateIdentity command using this blob.
      bytes blob_encrypted = 1;
    }

    oneof type {
      // IDevID challenge request for TPM 2.0 with IDevID systems.
      ChallengeRequestTPM20IDevID tpm20_idevid = 1;
      // HMAC challenge request for TPM 2.0 without IDevID systems.
      ChallengeRequestTPM20HMAC tpm20_hmac = 2;
      // EK challenge request for TPM 1.2 systems.
      ChallengeRequestTPM12EK tpm12_ek = 3;
    }
  }

  oneof type {
    ChallengeRequest challenge_request = 1;
    StreamBootstrapDataResponse bootstrap_response = 2;
    EmptyResponse report_status_response = 3;
  }
}
